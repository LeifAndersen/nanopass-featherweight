#lang typed/racket/base/no-check

(require racket/match
         "structs.rkt"
         (for-template racket/base
                       racket/match))

(provide build-processors
         find-nt
         build-body
         lookup-lang)

(: build-processors ((Syntaxof Any) pass -> (Syntaxof Any)))
(define (build-processors stx p)
  (match p
    [(pass name ilang olang formals returns processors definitions body)
     #`(#,@(for/list : (Listof (Syntaxof Any)) ([proc processors])
             (build-processor stx proc)))]))

(: build-processor ((Syntaxof Any) processor -> (Syntaxof Any)))
(define (build-processor stx proc)
  (match proc
    [(processor name int ont formals returns type body)
     #`(define (#,name #,@formals)
         #,(match type
             ['pattern
              #`(match #,(first formals)
                  #,@body
                  #,@(thread-productions int ont)
                  [else (error "Production not autogenerated")])]
             ['body body]))]))

(: find-nt (lang Identifier -> non-terminal))
(define (find-nt language nt)
  (match language
    [(lang name sname entry terminals non-terminals)
     (findf (lambda (x) (free-identifier=? nt (non-terminal-name x)))
            non-terminals)]))

(: build-body (lang (Listof Syntax) (U Syntax False) -> Syntax))
(define (build-body language formals body)
  (or body
      (match language
        [(lang name sname entry terminals non-terminals)
         #`(#,entry #,(first formals))])))

(: lookup-lang (Identifier -> (U lang False)))
(define (lookup-lang lang)
  (cond [(identifier? lang)
         (syntax-local-value lang)]
        [else #f]))

(: thread-productions (non-terminal non-terminal -> Syntax))
(define (thread-productions nt-i nt-o)
  #`(#,@(for/fold ([acc '()])
                  ([p (non-terminal-productions nt-i)])
          (match p
            [(production name sname fields pattern)
             (define p* (find-production pattern nt-o))
             (match p*
               [(production name* sname* fields* pattern*)
                (cons #`[(#,sname #,@(map (lambda (f) (production-field-name f)) fields))
                         (#,sname* #,@(map (lambda (f) (production-field-name f)) fields*))]
                      acc)]
               [#f acc])]))))

(: find-production (Syntax non-terminal -> production))
(define (find-production patt nt)
  (match nt
    [(non-terminal name sname alts productions parser)
     (findf (lambda (prod)
              (match prod
                [(production name sname fields patt*)
                 (equal? patt patt*)]))
            productions)]))
