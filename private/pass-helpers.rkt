#lang typed/racket/base/no-check

;; Helper functions for pass.rkt
;; In separate module because it's implemented in typed/racket.
;; However, typed/racket cannot produce correct contracts for syntax,
;; so the type checker is not run at compile time.
;; (Thus it's likely that the type annotations are out of date.)

(require racket/match
         "structs.rkt"
         (for-template racket/base
                       racket/match))

(provide build-processors
         find-nt
         build-body
         lookup-lang)

;; Turn processor struct into syntax for define-pass macro.
(: build-processors ((Syntaxof Any) pass -> (Syntaxof Any)))
(define (build-processors stx p)
  (match p
    [(pass name ilang olang formals returns processors definitions body)
     #`(#,@(for/list : (Listof (Syntaxof Any)) ([proc processors])
             (build-processor stx proc processors)))]))

; Build individual processor, for build-processors.
(: build-processor ((Syntaxof Any) processor (Listof processor) -> (Syntaxof Any)))
(define (build-processor stx proc others)
  (match proc
    [(processor name defname int ont formals returns type body)
     #`(define (#,defname #,@formals)
         #,(match type
             ['pattern
              #`(match #,(first formals)
                  #,@body
                  #,@(thread-productions int ont others)
                  [else (error '#,defname "Production not autogenerated ~a" else)])]
             ['body body]))]))

;; Find a non-terminal struct from a language, given the identifier for the struct.
;; The two names must be free-identifier=?.
(: find-nt (lang Identifier -> non-terminal))
(define (find-nt language nt)
  (match language
    [(lang name sname entry terminals non-terminals)
     (findf (lambda (x) (free-identifier=? nt (non-terminal-name x)))
            non-terminals)]))

;; Build the body of a pass.
;; Usually it will be of the form (Expr e).
(: build-body (lang (Listof processor) (Listof Syntax) (U Syntax False) -> Syntax))
(define (build-body language processors formals body)
  (or body
      (match language
        [(lang name sname entry terminals non-terminals)
         (define f (or (nt->processor entry processors)
                       (first processors)))
         #`(#,(processor-defname f) #,(first formals))])))

;; Lookup a language given it's identifier.
;; Returns false if the user didn't provide a language.
(: lookup-lang ((U Identifier False) -> (U lang False)))
(define (lookup-lang lang)
  (cond [(identifier? lang)
         (syntax-local-value lang)]
        [else #f]))

;; Generate extra pass code.
(: thread-productions (non-terminal non-terminal processors -> Syntax))
(define (thread-productions nt-i nt-o procs)
  #`(#,@(for/fold ([acc '()])
                  ([p (non-terminal-productions nt-i)])
          (match p
            [(production name sname fields pattern)
             (define p* (find-production pattern nt-o))
             (match p*
               [(production name* sname* fields* pattern*)
                (cons #`[(#,sname #,@(for/list ([f (in-list fields)])
                                       (production-field-name f)))
                         (#,sname* #,@(for/list ([f (in-list fields*)])
                                        (define name (production-field-name f))
                                        (define proc (production-field->processor f procs))
                                        (iterate-lists name
                                                       (and proc (processor-defname proc))
                                                       (production-field-depth f))))]
                      acc)]
               [#f acc])]))))

;; Given a pattern, find the correct prouction matching that pattern.
(: find-production (Syntax non-terminal -> production))
(define (find-production patt nt)
  (match nt
    [(non-terminal name sname alts productions parser)
     (findf (lambda (prod)
              (match prod
                [(production name sname fields patt*)
                 (equal? patt patt*)]))
            productions)]))

;; Return correct processor matcing non-terminal name.
;; False if no processor found.
(: nt->processor (Identifier (Listof processors) -> (U processor #f)))
(define (nt->processor nt-name processors)
  (findf (lambda (p)
           (match p
             [(processor name defname int ont formals returns type body)
              (free-identifier=? nt-name (non-terminal-name int))]))
         processors))

;; Return correct processor to match the production field.
;; False if no processor is found.
(: production-field->processor (production-field processors -> (U processor #f)))
(define (production-field->processor pf processors)
  (match pf
    [(production-field name symb depth)
     (findf (lambda (p)
              (match p
                [(processor name defname int ont formals returns type body)
                 (findf (lambda (alt)
                          (equal? (lang-symb-type symb)
                                  (syntax-e alt)))
                        (non-terminal-alts int))]))
            processors)]))

;; As meta-variables in patterns can have arbitrary ellipses depths,
;; we'll need to recur on each field in the struct's list to the correct depth.
(: iterate-lists (Syntax Syntax Integer -> Syntax))
(define (iterate-lists field defname depth)
  (define f (if defname #`(#,defname #,field) field))
  (if (depth . <= . 0)
      f
      #`(for/list ([i (in-list #,field)])
          #,(iterate-lists #'i defname (- depth 1)))))
