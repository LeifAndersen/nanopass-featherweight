#lang typed/racket/base/no-check

(require racket/match
         "structs.rkt"
         (for-template racket/base
                       racket/match))

(provide build-processors
         find-nt
         build-body
         lookup-lang)

(: build-processors ((Syntaxof Any) pass -> (Syntaxof Any)))
(define (build-processors stx p)
  (match p
    [(pass name ilang olang formals returns processors definitions body)
     #`(#,@(for/list : (Listof (Syntaxof Any)) ([proc processors])
             (build-processor stx proc processors)))]))

(: build-processor ((Syntaxof Any) processor (Listof processor) -> (Syntaxof Any)))
(define (build-processor stx proc others)
  (match proc
    [(processor name defname int ont formals returns type body)
     #`(define (#,defname #,@formals)
         #,(match type
             ['pattern
              #`(match #,(first formals)
                  #,@body
                  #,@(thread-productions int ont others)
                  [else (error '#,defname "Production not autogenerated ~a" else)])]
             ['body body]))]))

(: find-nt (lang Identifier -> non-terminal))
(define (find-nt language nt)
  (match language
    [(lang name sname entry terminals non-terminals)
     (findf (lambda (x) (free-identifier=? nt (non-terminal-name x)))
            non-terminals)]))

(: build-body (lang (Listof processor) (Listof Syntax) (U Syntax False) -> Syntax))
(define (build-body language processors formals body)
  (or body
      (match language
        [(lang name sname entry terminals non-terminals)
         (define f (or (nt->processor entry processors)
                       (first processors)))
         #`(#,(processor-defname f) #,(first formals))])))

(: lookup-lang (Identifier -> (U lang False)))
(define (lookup-lang lang)
  (cond [(identifier? lang)
         (syntax-local-value lang)]
        [else #f]))

(: thread-productions (non-terminal non-terminal processors -> Syntax))
(define (thread-productions nt-i nt-o procs)
  #`(#,@(for/fold ([acc '()])
                  ([p (non-terminal-productions nt-i)])
          (match p
            [(production name sname fields pattern)
             (define p* (find-production pattern nt-o))
             (match p*
               [(production name* sname* fields* pattern*)
                (cons #`[(#,sname #,@(for/list ([f (in-list fields)])
                                       (production-field-name f)))
                         (#,sname* #,@(for/list ([f (in-list fields*)])
                                        (define name (production-field-name f))
                                        (define proc (production-field->processor f procs))
                                        (define psymb (and proc #`(#,(processor-defname proc) #,name)))
                                        (or psymb name)))]
                      acc)]
               [#f acc])]))))

(: find-production (Syntax non-terminal -> production))
(define (find-production patt nt)
  (match nt
    [(non-terminal name sname alts productions parser)
     (findf (lambda (prod)
              (match prod
                [(production name sname fields patt*)
                 (equal? patt patt*)]))
            productions)]))

(: nt->processor (Identifier (Listof processors) -> (U processor #f)))
(define (nt->processor nt-name processors)
  (findf (lambda (p)
           (match p
             [(processor name defname int ont formals returns type body)
              (free-identifier=? nt-name (non-terminal-name int))]))
         processors))

(: production-field->processor (production-field processors -> (U processor #f)))
(define (production-field->processor pf processors)
  (match pf
    [(production-field name symb depth)
     (findf (lambda (p)
              (match p
                [(processor name defname int ont formals returns type body)
                 (findf (lambda (alt)
                          (equal? (lang-symb-type symb)
                                  (syntax-e alt)))
                        (non-terminal-alts int))]))
            processors)]))
